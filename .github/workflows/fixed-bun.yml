name: Apollo Federation CI (Fixed)

on:
  push:
    branches: ['main']
  pull_request:
    branches: ['main']
  workflow_dispatch:

# Prevent concurrent deployments of the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel in-progress runs to ensure zero downtime

env:
  HEALTH_CHECK_RETRIES: 10
  HEALTH_CHECK_INTERVAL: 10 # seconds

jobs:
  # Check repository structure first
  validate:
    runs-on: self-hosted
    timeout-minutes: 5
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: Check repository structure
        id: check-repo
        run: |
          echo "Repository structure:"
          ls -la
          
          # Store the repository root
          REPO_ROOT=$(pwd)
          echo "repo_root=$REPO_ROOT" >> $GITHUB_OUTPUT
          
          echo "Checking for backend services directories:"
          if [ -d "users" ]; then
            echo "✅ users directory found"
            if [ -f "users/package.json" ]; then
              echo "✅ users/package.json exists"
              echo "users_ok=true" >> $GITHUB_OUTPUT
            else
              echo "❌ users/package.json NOT found!"
              echo "users_ok=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ users directory NOT found!"
            echo "users_ok=false" >> $GITHUB_OUTPUT
          fi
          
          if [ -d "media" ]; then
            echo "✅ media directory found"
            if [ -f "media/package.json" ]; then
              echo "✅ media/package.json exists"
              echo "media_ok=true" >> $GITHUB_OUTPUT
            else
              echo "❌ media/package.json NOT found!"
              echo "media_ok=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ media directory NOT found!"
            echo "media_ok=false" >> $GITHUB_OUTPUT
          fi
          
          if [ -d "product" ]; then
            echo "✅ product directory found"
            if [ -f "product/package.json" ]; then
              echo "✅ product/package.json exists"
              echo "product_ok=true" >> $GITHUB_OUTPUT
            else
              echo "❌ product/package.json NOT found!"
              echo "product_ok=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ product directory NOT found!"
            echo "product_ok=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Search for package.json files
        if: steps.check-repo.outputs.users_ok != 'true' || steps.check-repo.outputs.media_ok != 'true' || steps.check-repo.outputs.product_ok != 'true'
        run: |
          echo "Searching for package.json files in the repository:"
          find . -name "package.json" -not -path "*/node_modules/*" -not -path "*/\.*"
  
  # 1. Deploy Users Subgraph first
  deploy-users:
    runs-on: self-hosted
    timeout-minutes: 15
    needs: validate
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Debug environment
        run: |
          echo "Current directory: $(pwd)"
          echo "Contents of current directory:"
          ls -la
          echo "Checking for users directory:"
          if [ -d "users" ]; then
            echo "users directory exists"
            echo "Contents of users directory:"
            ls -la users/
          else
            echo "users directory does not exist"
          fi

      - name: Set up Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
      
      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: |
            users/.bun
            users/node_modules
          key: ${{ runner.os }}-bun-users-${{ hashFiles('users/bun.lockb') }}
          restore-keys: |
            ${{ runner.os }}-bun-users-
            ${{ runner.os }}-bun-
      
      - name: Set environment variables
        run: |
          echo "SUB_GRAPH_NAME=users" >> $GITHUB_ENV
          echo "PORT=4001" >> $GITHUB_ENV
          echo "FRONTEND_URL=${{ secrets.FRONTEND_URL }}" >> $GITHUB_ENV
          echo "DB_TYPE=${{ secrets.DB_TYPE }}" >> $GITHUB_ENV
          echo "DB_HOST=${{ secrets.DB_HOST }}" >> $GITHUB_ENV
          echo "DB_PORT=${{ secrets.DB_PORT }}" >> $GITHUB_ENV
          echo "DB_USERNAME=${{ secrets.DB_USERNAME }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> $GITHUB_ENV
          echo "DB_NAME=${{ secrets.DB_NAME }}" >> $GITHUB_ENV
          echo "DB_SYNCHRONIZE=${{ secrets.DB_SYNCHRONIZE }}" >> $GITHUB_ENV
          echo "DB_ENTITIES=${{ secrets.DB_ENTITIES }}" >> $GITHUB_ENV
          echo "DB_MIGRATIONS=${{ secrets.DB_MIGRATIONS }}" >> $GITHUB_ENV
          echo "SALT_ROUNDS=${{ secrets.SALT_ROUNDS }}" >> $GITHUB_ENV
          echo "SECRET_KEY=${{ secrets.SECRET_KEY }}" >> $GITHUB_ENV
          echo "EXPIRE=${{ secrets.EXPIRE }}" >> $GITHUB_ENV
          echo "REDIS_HOST=${{ secrets.REDIS_HOST }}" >> $GITHUB_ENV
          echo "REDIS_PORT=${{ secrets.REDIS_PORT }}" >> $GITHUB_ENV
          echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" >> $GITHUB_ENV
          echo "REDIS_SESSION_TTL=${{ secrets.REDIS_SESSION_TTL }}" >> $GITHUB_ENV
          echo "EMAIL_HOST=${{ secrets.EMAIL_HOST }}" >> $GITHUB_ENV
          echo "EMAIL_PORT=${{ secrets.EMAIL_PORT }}" >> $GITHUB_ENV
          echo "EMAIL_USER=${{ secrets.EMAIL_USER }}" >> $GITHUB_ENV
          echo "EMAIL_FROM=${{ secrets.EMAIL_FROM }}" >> $GITHUB_ENV
          echo "EMAIL_PASSWORD=${{ secrets.EMAIL_PASSWORD }}" >> $GITHUB_ENV
          echo "NODE_ENV=${{ secrets.NODE_ENV }}" >> $GITHUB_ENV

      - name: Install dependencies
        run: |
          if [ ! -d "users" ]; then
            echo "::error::Users directory not found"
            exit 1
          fi
          
          cd users
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la
          
          if [ ! -f "package.json" ]; then
            echo "::error::package.json not found in users directory"
            exit 1
          fi
          
          echo "Installing dependencies with Bun..."
          bun install || {
            echo "::error::Failed to install dependencies. Trying with --verbose flag"
            bun install --verbose
            exit 1
          }

      - name: Check if service is already running and healthy
        id: health-check
        continue-on-error: true
        run: |
          ENDPOINT="http://localhost:4001/health"
          if curl -s -f "$ENDPOINT" > /dev/null; then
            echo "Current service is healthy"
            echo "is_healthy=true" >> $GITHUB_OUTPUT
          else
            echo "Current service is not healthy or not running"
            echo "is_healthy=false" >> $GITHUB_OUTPUT
          fi

      # Zero downtime deployment strategy
      - name: Deploy with zero downtime
        run: |
          set -e
          echo "Deploying users subgraph"
          
          PM2_NAME="sunshine_users_subgraph"
          PORT=4001
          HEALTH_ENDPOINT="/health"
          
          # Verify we're in the right directory with package.json
          if [ ! -f "package.json" ]; then
            echo "::error::No package.json found in current directory $(pwd)"
            exit 1
          fi
          
          # Check if PM2 process exists
          if pm2 list | grep -q "$PM2_NAME"; then
            echo "Starting new instance before stopping the old one for zero downtime"
            
            # Create a temporary process for the new version
            TEMP_PM2_NAME="${PM2_NAME}_new"
            
            # Start new process on a different port
            TEMP_PORT=$((PORT+1000))
            echo "Starting new instance on PORT $TEMP_PORT"
            
            # Set PORT environment variable and start PM2 process
            pm2 start bun --name $TEMP_PM2_NAME --env PORT=$TEMP_PORT -- start
            
            # Wait for new service to be healthy
            TEMP_ENDPOINT="http://localhost:$TEMP_PORT$HEALTH_ENDPOINT"
            RETRY_COUNTER=0
            
            echo "Waiting for new service to be healthy at $TEMP_ENDPOINT"
            until curl -s -f "$TEMP_ENDPOINT" > /dev/null || [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; do
              echo "Health check attempt $RETRY_COUNTER failed, retrying in ${{ env.HEALTH_CHECK_INTERVAL }} seconds..."
              RETRY_COUNTER=$((RETRY_COUNTER+1))
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
              
              if [ $RETRY_COUNTER -eq 3 ]; then
                echo "PM2 logs for troubleshooting:"
                pm2 logs $TEMP_PM2_NAME --lines 20
              fi
            done
            
            if [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
              echo "::error::New service failed to start properly after multiple attempts!"
              pm2 logs $TEMP_PM2_NAME --lines 50
              pm2 delete $TEMP_PM2_NAME
              exit 1
            fi
            
            echo "New service is healthy, switching over"
            
            # Stop the old process
            pm2 delete $PM2_NAME
            
            # Restart the new process on the correct port
            pm2 stop $TEMP_PM2_NAME
            
            # Restore original port and start on the correct port with the correct name
            pm2 start bun --name $PM2_NAME --env PORT=$PORT -- start
            
            # Delete temporary process
            pm2 delete $TEMP_PM2_NAME
          else
            echo "No existing process found, starting fresh"
            pm2 start bun --name $PM2_NAME --env PORT=$PORT -- start
          fi
        working-directory: users
      
      - name: Verify service health
        run: |
          ENDPOINT="http://localhost:4001/health"
          RETRY_COUNTER=0
          
          echo "Verifying users health at $ENDPOINT"
          until curl -s -f "$ENDPOINT" > /dev/null || [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; do
            echo "Health check attempt $RETRY_COUNTER failed, retrying in ${{ env.HEALTH_CHECK_INTERVAL }} seconds..."
            RETRY_COUNTER=$((RETRY_COUNTER+1))
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            
            if [ $RETRY_COUNTER -eq 3 ]; then
              echo "PM2 logs for troubleshooting:"
              pm2 logs sunshine_users_subgraph --lines 20
            fi
          done
          
          if [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
            echo "::error::Service users failed to start properly after multiple attempts!"
            pm2 logs sunshine_users_subgraph --lines 50
            exit 1
          else
            echo "Service users is healthy and operational!"
          fi

  # 2. Deploy Media Subgraph after Users is healthy
  deploy-media:
    runs-on: self-hosted
    timeout-minutes: 15
    needs: deploy-users
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
      
      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: |
            media/.bun
            media/node_modules
          key: ${{ runner.os }}-bun-media-${{ hashFiles('media/bun.lockb') }}
          restore-keys: |
            ${{ runner.os }}-bun-media-
            ${{ runner.os }}-bun-
      
      - name: Set environment variables
        run: |
          echo "SUB_GRAPH_NAME=media" >> $GITHUB_ENV
          echo "PORT=4002" >> $GITHUB_ENV
          echo "FRONTEND_URL=${{ secrets.FRONTEND_URL }}" >> $GITHUB_ENV
          echo "DB_TYPE=${{ secrets.DB_TYPE }}" >> $GITHUB_ENV
          echo "DB_HOST=${{ secrets.DB_HOST }}" >> $GITHUB_ENV
          echo "DB_PORT=${{ secrets.DB_PORT }}" >> $GITHUB_ENV
          echo "DB_USERNAME=${{ secrets.DB_USERNAME }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> $GITHUB_ENV
          echo "DB_NAME=${{ secrets.DB_NAME }}" >> $GITHUB_ENV
          echo "DB_SYNCHRONIZE=${{ secrets.DB_SYNCHRONIZE }}" >> $GITHUB_ENV
          echo "DB_ENTITIES=${{ secrets.DB_ENTITIES }}" >> $GITHUB_ENV
          echo "DB_MIGRATIONS=${{ secrets.DB_MIGRATIONS }}" >> $GITHUB_ENV
          echo "SALT_ROUNDS=${{ secrets.SALT_ROUNDS }}" >> $GITHUB_ENV
          echo "SECRET_KEY=${{ secrets.SECRET_KEY }}" >> $GITHUB_ENV
          echo "EXPIRE=${{ secrets.EXPIRE }}" >> $GITHUB_ENV
          echo "REDIS_HOST=${{ secrets.REDIS_HOST }}" >> $GITHUB_ENV
          echo "REDIS_PORT=${{ secrets.REDIS_PORT }}" >> $GITHUB_ENV
          echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" >> $GITHUB_ENV
          echo "REDIS_SESSION_TTL=${{ secrets.REDIS_SESSION_TTL }}" >> $GITHUB_ENV
          echo "EMAIL_HOST=${{ secrets.EMAIL_HOST }}" >> $GITHUB_ENV
          echo "EMAIL_PORT=${{ secrets.EMAIL_PORT }}" >> $GITHUB_ENV
          echo "EMAIL_USER=${{ secrets.EMAIL_USER }}" >> $GITHUB_ENV
          echo "EMAIL_FROM=${{ secrets.EMAIL_FROM }}" >> $GITHUB_ENV
          echo "EMAIL_PASSWORD=${{ secrets.EMAIL_PASSWORD }}" >> $GITHUB_ENV
          echo "NODE_ENV=${{ secrets.NODE_ENV }}" >> $GITHUB_ENV

      - name: Install dependencies
        run: |
          if [ ! -d "media" ]; then
            echo "::error::Media directory not found"
            exit 1
          fi
          
          cd media
          echo "Current directory: $(pwd)"
          
          if [ ! -f "package.json" ]; then
            echo "::error::package.json not found in media directory"
            exit 1
          fi
          
          echo "Installing dependencies with Bun..."
          bun install || {
            echo "::error::Failed to install dependencies"
            exit 1
          }

      - name: Deploy with zero downtime
        run: |
          set -e
          echo "Deploying media subgraph"
          
          PM2_NAME="sunshine_media_subgraph"
          PORT=4002
          HEALTH_ENDPOINT="/health"
          
          # Verify we're in the right directory with package.json
          if [ ! -f "package.json" ]; then
            echo "::error::No package.json found in current directory $(pwd)"
            exit 1
          fi
          
          # Check if PM2 process exists
          if pm2 list | grep -q "$PM2_NAME"; then
            echo "Starting new instance before stopping the old one for zero downtime"
            
            # Create a temporary process for the new version
            TEMP_PM2_NAME="${PM2_NAME}_new"
            
            # Start new process on a different port
            TEMP_PORT=$((PORT+1000))
            echo "Starting new instance on PORT $TEMP_PORT"
            
            # Set PORT environment variable and start PM2 process
            pm2 start bun --name $TEMP_PM2_NAME --env PORT=$TEMP_PORT -- start
            
            # Wait for new service to be healthy
            TEMP_ENDPOINT="http://localhost:$TEMP_PORT$HEALTH_ENDPOINT"
            RETRY_COUNTER=0
            
            echo "Waiting for new service to be healthy at $TEMP_ENDPOINT"
            until curl -s -f "$TEMP_ENDPOINT" > /dev/null || [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; do
              echo "Health check attempt $RETRY_COUNTER failed, retrying in ${{ env.HEALTH_CHECK_INTERVAL }} seconds..."
              RETRY_COUNTER=$((RETRY_COUNTER+1))
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            done
            
            if [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
              echo "::error::New service failed to start properly after multiple attempts!"
              pm2 logs $TEMP_PM2_NAME --lines 50
              pm2 delete $TEMP_PM2_NAME
              exit 1
            fi
            
            echo "New service is healthy, switching over"
            
            # Stop the old process
            pm2 delete $PM2_NAME
            
            # Restart the new process on the correct port
            pm2 stop $TEMP_PM2_NAME
            
            # Restore original port and start on the correct port with the correct name
            pm2 start bun --name $PM2_NAME --env PORT=$PORT -- start
            
            # Delete temporary process
            pm2 delete $TEMP_PM2_NAME
          else
            echo "No existing process found, starting fresh"
            pm2 start bun --name $PM2_NAME --env PORT=$PORT -- start
          fi
        working-directory: media
      
      - name: Verify service health
        run: |
          ENDPOINT="http://localhost:4002/health"
          RETRY_COUNTER=0
          
          echo "Verifying media health at $ENDPOINT"
          until curl -s -f "$ENDPOINT" > /dev/null || [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; do
            echo "Health check attempt $RETRY_COUNTER failed, retrying in ${{ env.HEALTH_CHECK_INTERVAL }} seconds..."
            RETRY_COUNTER=$((RETRY_COUNTER+1))
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
          done
          
          if [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
            echo "::error::Service media failed to start properly after multiple attempts!"
            pm2 logs sunshine_media_subgraph --lines 50
            exit 1
          else
            echo "Service media is healthy and operational!"
          fi

  # 3. Deploy Product Subgraph after Media is healthy
  deploy-product:
    runs-on: self-hosted
    timeout-minutes: 15
    needs: deploy-media
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
      
      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: |
            product/.bun
            product/node_modules
          key: ${{ runner.os }}-bun-product-${{ hashFiles('product/bun.lockb') }}
          restore-keys: |
            ${{ runner.os }}-bun-product-
            ${{ runner.os }}-bun-

      - name: Set environment variables
        run: |
          echo "SUB_GRAPH_NAME=product" >> $GITHUB_ENV
          echo "PORT=4003" >> $GITHUB_ENV
          echo "FRONTEND_URL=${{ secrets.FRONTEND_URL }}" >> $GITHUB_ENV
          echo "DB_TYPE=${{ secrets.DB_TYPE }}" >> $GITHUB_ENV
          echo "DB_HOST=${{ secrets.DB_HOST }}" >> $GITHUB_ENV
          echo "DB_PORT=${{ secrets.DB_PORT }}" >> $GITHUB_ENV
          echo "DB_USERNAME=${{ secrets.DB_USERNAME }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> $GITHUB_ENV
          echo "DB_NAME=${{ secrets.DB_NAME }}" >> $GITHUB_ENV
          echo "DB_SYNCHRONIZE=${{ secrets.DB_SYNCHRONIZE }}" >> $GITHUB_ENV
          echo "DB_ENTITIES=${{ secrets.DB_ENTITIES }}" >> $GITHUB_ENV
          echo "DB_MIGRATIONS=${{ secrets.DB_MIGRATIONS }}" >> $GITHUB_ENV
          echo "SALT_ROUNDS=${{ secrets.SALT_ROUNDS }}" >> $GITHUB_ENV
          echo "SECRET_KEY=${{ secrets.SECRET_KEY }}" >> $GITHUB_ENV
          echo "EXPIRE=${{ secrets.EXPIRE }}" >> $GITHUB_ENV
          echo "REDIS_HOST=${{ secrets.REDIS_HOST }}" >> $GITHUB_ENV
          echo "REDIS_PORT=${{ secrets.REDIS_PORT }}" >> $GITHUB_ENV
          echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" >> $GITHUB_ENV
          echo "REDIS_SESSION_TTL=${{ secrets.REDIS_SESSION_TTL }}" >> $GITHUB_ENV
          echo "EMAIL_HOST=${{ secrets.EMAIL_HOST }}" >> $GITHUB_ENV
          echo "EMAIL_PORT=${{ secrets.EMAIL_PORT }}" >> $GITHUB_ENV
          echo "EMAIL_USER=${{ secrets.EMAIL_USER }}" >> $GITHUB_ENV
          echo "EMAIL_FROM=${{ secrets.EMAIL_FROM }}" >> $GITHUB_ENV
          echo "EMAIL_PASSWORD=${{ secrets.EMAIL_PASSWORD }}" >> $GITHUB_ENV
          echo "NODE_ENV=${{ secrets.NODE_ENV }}" >> $GITHUB_ENV

      - name: Install dependencies
        run: |
          if [ ! -d "product" ]; then
            echo "::error::Product directory not found"
            exit 1
          fi
          
          cd product
          echo "Current directory: $(pwd)"
          
          if [ ! -f "package.json" ]; then
            echo "::error::package.json not found in product directory"
            exit 1
          fi
          
          echo "Installing dependencies with Bun..."
          bun install || {
            echo "::error::Failed to install dependencies"
            exit 1
          }

      - name: Deploy with zero downtime
        run: |
          set -e
          echo "Deploying product subgraph"
          
          PM2_NAME="sunshine_product_subgraph"
          PORT=4003
          HEALTH_ENDPOINT="/health"
          
          # Verify we're in the right directory with package.json
          if [ ! -f "package.json" ]; then
            echo "::error::No package.json found in current directory $(pwd)"
            exit 1
          fi
          
          # Check if PM2 process exists
          if pm2 list | grep -q "$PM2_NAME"; then
            echo "Starting new instance before stopping the old one for zero downtime"
            
            # Create a temporary process for the new version
            TEMP_PM2_NAME="${PM2_NAME}_new"
            
            # Start new process on a different port
            TEMP_PORT=$((PORT+1000))
            echo "Starting new instance on PORT $TEMP_PORT"
            
            # Set PORT environment variable and start PM2 process
            pm2 start bun --name $TEMP_PM2_NAME --env PORT=$TEMP_PORT -- start
            
            # Wait for new service to be healthy
            TEMP_ENDPOINT="http://localhost:$TEMP_PORT$HEALTH_ENDPOINT"
            RETRY_COUNTER=0
            
            echo "Waiting for new service to be healthy at $TEMP_ENDPOINT"
            until curl -s -f "$TEMP_ENDPOINT" > /dev/null || [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; do
              echo "Health check attempt $RETRY_COUNTER failed, retrying in ${{ env.HEALTH_CHECK_INTERVAL }} seconds..."
              RETRY_COUNTER=$((RETRY_COUNTER+1))
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            done
            
            if [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
              echo "::error::New service failed to start properly after multiple attempts!"
              pm2 logs $TEMP_PM2_NAME --lines 50
              pm2 delete $TEMP_PM2_NAME
              exit 1
            fi
            
            echo "New service is healthy, switching over"
            
            # Stop the old process
            pm2 delete $PM2_NAME
            
            # Restart the new process on the correct port
            pm2 stop $TEMP_PM2_NAME
            
            # Restore original port and start on the correct port with the correct name
            pm2 start bun --name $PM2_NAME --env PORT=$PORT -- start
            
            # Delete temporary process
            pm2 delete $TEMP_PM2_NAME
          else
            echo "No existing process found, starting fresh"
            pm2 start bun --name $PM2_NAME --env PORT=$PORT -- start
          fi
        working-directory: product
      
      - name: Verify service health
        run: |
          ENDPOINT="http://localhost:4003/health"
          RETRY_COUNTER=0
          
          echo "Verifying product health at $ENDPOINT"
          until curl -s -f "$ENDPOINT" > /dev/null || [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; do
            echo "Health check attempt $RETRY_COUNTER failed, retrying in ${{ env.HEALTH_CHECK_INTERVAL }} seconds..."
            RETRY_COUNTER=$((RETRY_COUNTER+1))
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
          done
          
          if [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
            echo "::error::Service product failed to start properly after multiple attempts!"
            pm2 logs sunshine_product_subgraph --lines 50
            exit 1
          else
            echo "Service product is healthy and operational!"
          fi

  # 4. Deploy Router after all subgraphs are healthy
  deploy-router:
    runs-on: self-hosted
    needs: [deploy-users, deploy-media, deploy-product]
    timeout-minutes: 10
    defaults:
      run:
        working-directory: router

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Verify all subgraphs are healthy before updating router
        run: |
          echo "Verifying all subgraphs are healthy before updating the router..."
          
          # Check users subgraph
          USERS_ENDPOINT="http://localhost:4001/health"
          if ! curl -s -f "$USERS_ENDPOINT" > /dev/null; then
            echo "::error::Users subgraph is not healthy!"
            exit 1
          else
            echo "Users subgraph is healthy"
          fi
          
          # Check media subgraph
          MEDIA_ENDPOINT="http://localhost:4002/health"
          if ! curl -s -f "$MEDIA_ENDPOINT" > /dev/null; then
            echo "::error::Media subgraph is not healthy!"
            exit 1
          else
            echo "Media subgraph is healthy"
          fi
          
          # Check product subgraph
          PRODUCT_ENDPOINT="http://localhost:4003/health"
          if ! curl -s -f "$PRODUCT_ENDPOINT" > /dev/null; then
            echo "::error::Product subgraph is not healthy!"
            exit 1
          else
            echo "Product subgraph is healthy"
          fi
          
          echo "All subgraphs are operational, safe to update router!"

      - name: Debug router directory
        run: |
          echo "Current directory: $(pwd)"
          echo "Contents of router directory:"
          ls -la
          
          if [ ! -f "package.json" ]; then
            echo "::warning::No package.json found in router directory"
          fi

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20
          cache: 'npm'
          cache-dependency-path: router/package-lock.json

      - name: Install dependencies
        run: |
          if [ -f "package.json" ]; then
            npm ci
          else
            echo "::error::No package.json found in router directory"
            exit 1
          fi
        
      - name: Install Rover if not present
        run: |
          if ! command -v rover &> /dev/null; then
            echo "Installing rover..."
            curl -sSL https://rover.apollo.dev/nix/latest | sh -s -- --force
            echo "$HOME/.rover/bin" >> $GITHUB_PATH
            export PATH="$HOME/.rover/bin:$PATH"
          else
            echo "Rover already installed. Skipping."
          fi

      - name: Ensure Apollo Router binary is executable
        run: |
          if [ -f "./router" ]; then
            chmod +x ./router
          else
            echo "::warning::Router binary not found"
          fi

      # Apply zero-downtime strategy for router
      - name: Deploy Router with zero downtime
        run: |
          set -e
          ROUTER_PORT=4000
          TEMP_ROUTER_PORT=5000
          
          echo "Checking if Apollo Router is already running..."
          ROUTER_RUNNING=false
          if pm2 list | grep -q "sunshine_router"; then
            echo "Apollo Router is already running"
            ROUTER_RUNNING=true
            
            # Check if current router is healthy
            if curl -s -f "http://localhost:$ROUTER_PORT/.well-known/apollo/server-health" > /dev/null; then
              echo "Current Router is healthy"
            else
              echo "Current Router is not healthy, will replace it"
            fi
          fi
          
          if [ "$ROUTER_RUNNING" = true ]; then
            echo "Starting new Router instance on temporary port before stopping the existing one"
            
            # Create temporary process for the new version
            TEMP_ROUTER_NAME="sunshine_router_new"
            
            # Set up environment for temporary router
            export ROUTER_PORT=$TEMP_ROUTER_PORT
            
            # Start new router process
            echo "Starting new Router on port $TEMP_ROUTER_PORT"
            pm2 start npm --name $TEMP_ROUTER_NAME -- start
            
            # Wait for new router to be healthy
            RETRY_COUNTER=0
            echo "Checking health of new Router at http://localhost:$TEMP_ROUTER_PORT/.well-known/apollo/server-health"
            until curl -s -f "http://localhost:$TEMP_ROUTER_PORT/.well-known/apollo/server-health" > /dev/null || [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; do
              echo "Health check attempt $RETRY_COUNTER failed, retrying in ${{ env.HEALTH_CHECK_INTERVAL }} seconds..."
              RETRY_COUNTER=$((RETRY_COUNTER+1))
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
              
              if [ $RETRY_COUNTER -eq 3 ]; then
                echo "PM2 logs for troubleshooting:"
                pm2 logs $TEMP_ROUTER_NAME --lines 20
              fi
            done
            
            if [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
              echo "::error::New Router failed to start properly after multiple attempts!"
              pm2 logs $TEMP_ROUTER_NAME --lines 50
              pm2 delete $TEMP_ROUTER_NAME
              exit 1
            fi
            
            echo "New Router is healthy, switching traffic over..."
            
            # Now we have a healthy new instance, stop the old one
            pm2 delete sunshine_router
            
            # Stop the temporary process
            pm2 stop $TEMP_ROUTER_NAME
            
            # Restore original port environment
            export ROUTER_PORT=4000
            
            # Start with the correct name and port
            pm2 start npm --name sunshine_router -- start
            
            # Delete temporary process
            pm2 delete $TEMP_ROUTER_NAME
          else
            echo "No existing Router found, starting fresh"
            pm2 start npm --name sunshine_router -- start
          fi
          
      - name: Verify Router Health
        run: |
          ROUTER_PORT=4000
          RETRY_COUNTER=0
          
          echo "Verifying Router health at http://localhost:$ROUTER_PORT/.well-known/apollo/server-health"
          until curl -s -f "http://localhost:$ROUTER_PORT/.well-known/apollo/server-health" > /dev/null || [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; do
            echo "Health check attempt $RETRY_COUNTER failed, retrying in ${{ env.HEALTH_CHECK_INTERVAL }} seconds..."
            RETRY_COUNTER=$((RETRY_COUNTER+1))
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            
            if [ $RETRY_COUNTER -eq 3 ]; then
              echo "PM2 logs for troubleshooting:"
              pm2 logs sunshine_router --lines 20
            fi
          done
          
          if [ $RETRY_COUNTER -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
            echo "::error::Apollo Router failed to start properly after multiple attempts!"
            pm2 logs sunshine_router --lines 50
            exit 1
          else
            echo "Apollo Router is healthy and operational!"
            echo "Deployment completed successfully with zero downtime!"
          fi
